/*
* The UrbanEye PND solution is a collection of packages based on native C++ classes
* that implement the fundamental algorithms & operations required to satisfy one kind
* of mobile or portable devices with competitive qualities being a leading one.
*
* Copyright (C) 2008 Xiujie Sheng
*
* This library isn't a free software, so you cann't take the sourcecode without author's permit.
* Of course, there is NO ANY WARRANTY that this library will harm your computer or ongoing business 
* if you illegally got it. 
*
* NOTE: 
* AUTHOR WOULD ALWAYS RESERVE LEGAL RIGHT TO PROTECT WHAT HE HAVE DONE ACCORDING TO
* LOCAL OR INTERNATIONAL COPYRIGHT OR RELATIVE LAW(S).
*
* For more information, contact:
*
* China University of Geoseciences(Wuhan)
* Graduate School
*
* Xiujie Sheng
* smartpoint@sohu.com
*/
#ifndef _UEBASE_FILEBASIC_H
#define _UEBASE_FILEBASIC_H

// Refer to concrete compile conditions or different platform defintions
#ifndef _MAKE_OPTIONS_H
#include "makeopts.h"
#endif

// Refer to Export and Import macroes
#ifndef _UEBASE_DEF_H
#include "uebase.h"
#endif

// Refer to utility functions encapsulated by <code> CPathBasic </code>
#ifndef _UEBASE_PATHBASIC_H
#include "pathbasic.h"
#endif

// UeBase
namespace UeBase
{
  /**
  * \brief Basic and different kinds of operations when accessing one file and it is also the set of utility .
  *
  * \detail This class supports different ways to access one file including std C, native functions relative one OS etc, 
  * different modes for CRUD etc. Of course, those plain file also should include URL etc. But this class shouldn't
  * support special file kind like COM etc as it need more parameters-depedent.
  *
  * There is an obvious advantage that when facing port issues, we only have to focus here but not every where. However,
  * it should cause little performance penality when opening or writing one file since there are some decision conditions
  * before really playing.
  *
  * Note:
  * The default data stream here is always binary stream not text
  */
  class UEBASE_CLASS CFileBasic
  {
  public:
    /**
    * \brief Different file libraries
    */
    enum UtilityLib
    {
      /// Not specified yet
      UL_Unknown = 0,	
      /// Refer to standard C libraries
      UL_Stand,		
      /// Refer to STL
      UL_STL,			
      /// Limited to one concrete os
      UL_Native		
    };

    /**
    * Encapsulate different file open mode
    */
#if __UE_STANDC__
    const static int UE_SEEK_BEGIN = SEEK_SET;
    const static int UE_SEEK_CUR = SEEK_CUR;
    const static int UE_SEEK_END = SEEK_END;
#endif

#if __UE_WINDOWS__
    // Open modes
    const static int UE_FILE_APPEND	= 0; // This macro shouldn't play role when using Windows APIs
    const static int UE_FILE_WRITE = GENERIC_WRITE;
    const static int UE_FILE_READ = GENERIC_READ;
    const static int UE_FILE_EXECUTE = GENERIC_EXECUTE;
    const static int UE_FILE_ALL = GENERIC_ALL;
#elif
    // TODO:
#pragma message("Here lack defintions!")
#endif

  private:
    //
    // Constructors & deconstructor: this class shouldn't occur in any sence except for as one singleton
    //
    /**
    * \brief Default constructor.
    *
    * \detail Since it needs at least one construcotor to resolve its member refer to which, but there should make caution
    * about the initialization order of <code> CPathBasic </code> and <code> CFileBasic </code> considering issues
    * about static variable initialization
    */
    CFileBasic() : m_pathBasic(CPathBasic::Get())
    {
    }

    /**
    * \brief Deconstructor.
    *
    * Occuring accompany the constructor definition not decalaration: since this class can occur, it must have its
    * dctr implementation.
    */
    ~CFileBasic()
    {
    }

    /**
    * \brief Copy constructor
    *
    * \detail No any secenes to let this class occur except for the initialization of static variable.
    *
    * \param other CFileBasic实例
    */
    CFileBasic(const CFileBasic &other);

    /**
    * \brief 赋值操作符
    *
    * \param other CFileBasic实例
    */
    const CFileBasic &operator=(const CFileBasic &other);

  public:
    //
    // File access operations
    //
    // Note: Since we are reluctant to declare any member variables in this class for the reason of singletion,
    // we have to pass extra parameters in order to indicate some statuses while impose stronger pre-condition
    // before using below functions as they should follow the same status, for example, follow the same utility
    // lib.
    //
    /**
    * \brief Check validity of one file handle according to different <code> UtilityLib </code> definition.
    *
    * \param fileHandle the file handle generated by <code> OpenFile </code>
    * \param ioLib 依赖的底层库，枚举值参见UtilityLib的定义
    */
    bool IsValidHandle(void *const fileHandle, UtilityLib ioLib = UL_Stand) const;

    /**
    * \brief Get defintion of valid handle against different I/O APIs
    *
    * \param ioLib 依赖的底层库，枚举值参见UtilityLib的定义
    */
    void *GetValidHandle(UtilityLib ioLib = UL_Stand) const;

    /**
    * \brief Open a file accoring to specified utility library.
    *
    * \param fileName which file be opened
    * \param mode all access mode in string way
    * \param ioLib 依赖的底层库，枚举值参见UtilityLib的定义
    * \return the maximum generality of different data types and it can be converted into
    * counterparts: HANDLE for FL_Native, FILE for FL_Stand etc.
    */
    void *OpenFile(const tstring &fileName, int mode = UE_FILE_ALL, UtilityLib ioLib = UL_Stand) const;

    /**
    * \brief Move current reader pointer.
    *
    * Note: this function currently is limited to UL_Stand lib.
    *
    * \param fileHandle 文件句柄
    * \param offset 偏移量
    * \param whence seek起始位置
    * \param ioLib 当前仅限于使用UL_Stand
    */
    bool SeekFile(void *const fileHandle, int offset, int whence = UE_SEEK_BEGIN, UtilityLib ioLib = UL_Stand) const;

    /**
    * \brief Read File.
    *
    * Note:
    * Here no any constness semantic definition for parameter buf since it maybe null and need to be allocated then filled
    * in this function side.
    * But when passing the pointer to pointer to one stack variable, should be careful:
    * STRUCT str[10];
    * STRUCT *strPointer = &str;
    * ReadFile(,,(void **)(&strPointer))
    *
    * \param fileHandle the file handle
    * \param buf the pointer to pointer to one memory in order to support memory allocation by this function.
    * \param size the data size for read
    * \param count the number of data unit in specified size while indicating how many it read
    * \param ioLib delegate to which utility libraries
    * \return whether successifully do once read action even if it only read part
    */
    bool ReadFile(void *const fileHandle, void **buf, int size, int &count, UtilityLib ioLib = UL_Stand) const;

    /**
    * \brief Write file.
    *
    * \param fileHandle 文件句柄
    * \param buf 写入数据的缓冲区
    * \param size 写入的数据单元的大小
    * \param count 写入的数据单元的数量
    * \param ioLib 依赖的底层库，枚举值参见UtilityLib的定义
    */
    bool WriteFile(void *const fileHandle, const void *const buf, int size, int count, UtilityLib ioLib = UL_Stand) const;

    /**
    * \brief Write those content not stored into disk file yet.
    *
    * Note: this function currently is limited to UL_Stand lib.
    * \param fileHandle 文件句柄
    * \param ioLib 当前仅限于使用UL_Stand
    */
    bool FlushFile(void *const fileHandle, UtilityLib ioLib = UL_Stand) const;

    /**
    * \brief 获得文件大小
    * 
    * \param fileHandle 文件句柄
    * \param ioLib 依赖的底层库，枚举值参见UtilityLib的定义
    */
    int GetFileSize(void *const fileHandle, UtilityLib ioLib = UL_Stand) const;

    /**
    * \brief 获得游标当前位置
    *
    * \param fileHandle 文件句柄
    * \param ioLib 依赖的底层库，枚举值参见UtilityLib的定义
    */
    int TellFilePos(void *const fileHandle, UtilityLib ioLib = UL_Stand) const;

    /**
    * \brief Close file handle.
    *
    * \param fileHandle 文件句柄
    * \param ioLib 依赖的底层库，枚举值参见UtilityLib的定义
    */
    void CloseFile(void *const fileHandle, UtilityLib ioLib = UL_Stand) const;


    //
    // Memory mapping mechansim
    // Note: the mapped memory just be shared in readable not writable way.
    //
    /**
    * \brief Directly map the file into the memory address.
    *
    * \detail The defintion of this function is simply defined by those MS APIs related to file mapping mechansim, so some
    * parameters maybe play nothing when porting to other OS variaties. The advantage of this function is at least obvious that
    * no more than one code peices scattered every where, just here:)
    *
    * \param oneFile the file needed to be mapped
    * \param fileHandle the handle when opening this file
    * \param memoryHandle the mapped handle related to OS MMU, namely, memory management unit.
    * \param ioLib use which mapping mechansim which limited to one OS generally
    * \return the pointer to the first position of memory block just mapped
    */
    bool CreateMemoryMapping(const tstring &oneFile, void **fileHandle, void **memoryHandle, void **memoryData, UtilityLib ioLib = UL_Stand) const;

    /**
    * \brief Release memory kinds for mapping mechanism: file handle, mapping handle, virtual memory mapped
    * Note:
    * Here still pass two dimensions of pointers in order to assign correct value after release action according to
    * different I/O libraries
    *
    * \param fileHandle 指向文件句柄的指针
    * \param memoryHandle 指向内存句柄的指针
    * \param memoryData 指向映射内存指针的指针
    * \param ioLib 依赖的底层库，枚举值参见UtilityLib的定义
    */
    bool ReleaseMemoryMapping(void **fileHandle, void **memoryHandle, void **memoryData, UtilityLib ioLib = UL_Stand) const;

    // 
    // Singletion function
    //
    /**
    * \brief Extra work is to initialize the static variable when the first time to call this function
    */
    static const CFileBasic &Get();
	static char *GetLine(char *buffer,int maximum,void *fileHandle);

  private:
    /// Refer to utility functions for path operations
    const CPathBasic &m_pathBasic;

    /// Singleton
    static CFileBasic m_fileBasic;
  };
}
#endif